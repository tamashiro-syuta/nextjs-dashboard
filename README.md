# Next.js(App Router) の公式チュートリアル
- https://nextjs.org/learn/dashboard-app

以下、各章のメモ

## CSS Style
### Tailwind
- Tailwind用のスタイルを用意していて、それにするとglobal.cssに設定済みになる
  - `/app/layout.tsx` には自分でimportする必要あり

### CSS Modules
- CSS モジュールを 使用すると、一意のクラス名を自動的に作成することで CSS の範囲をコンポーネントに設定できるため、名前の衝突を心配する必要がなくなる
- サンプルでは`/app/ui/home.module.css`って命名していたから、`〇〇.modules.css`ってするのが一般的と思われる

### clsx
- `clsx`っていうライブラリを使うと、条件分岐しながらスタイルをかけるから複雑なスタイリングしやすくなるっぽい (他のCSSinJSとあんまり変わらない印象)
- 公式ではサンプルだから下の感じでやってたけど、実際使う時は`className`に直接書かずに、スタイルの条件をカプセル化した方が良いかも
  ```javascript
  className={clsx(
    'inline-flex items-center rounded-full px-2 py-1 text-sm',
    {
      'bg-gray-100 text-gray-500': status === 'pending',
      'bg-green-500 text-white': status === 'paid',
    },
  )}
  ```

## フォントと画像の最適化
### フォント
- **【 結論: `next/font` を使え 】**
- ブラウザでは最初にフォールバックフォント or システムフォントでテキストをレンダリング
- それが読み込まれるとカスタムフォントに置き換わるときに発生する
- この入れ替えによって、テキストのサイズ、間隔、レイアウトが変更され、周囲の要素が移動することがある
- next.jsは、next/fontモジュールを使用すると、アプリケーション内のフォントを自動的に最適化する
- これは、ビルド時にフォントファイルをダウンロードし、他の静的アセットと一緒にホスティングすることによって行われる
- つまり、ユーザーがアプリケーションにアクセスしたときに、パフォーマンスに影響するようなフォントの追加ネットワークリクエストが発生しない

### 画像
- **【 結論: `next/image` を使え 】**
- `next/image`は以下の機能を自動で行う
  - 画像読み込み時に自動的にレイアウトがずれるのを防ぐ
  - 小さなビューポートを備えたデバイスに大きな画像が送信されるのを避けるために、画像のサイズを変更する
  - デフォルトで画像を遅延読み込み (画像はビューポートに入るときに読み込まれる)
  - WebPやAVIなどの最新の形式で画像を提供(※ブラウザがサポートしている場合)
  - 画像のサイズをheightプロパティとwidthプロパティで指定するのはベストプラクティス
  - デバイスのサイズごとに画像のサイズ等を変更したい時は、`Image`コンポーネントを複数用意して、`tailwind`の`hidden`などで出し分けるのもあり

## layoutとpageの作成
- layoutは配下のコンポーネントへ遷移する際は再レンダリングされずに最適化される(`partial rendering`)

## ページ間のnavigate
- `a`タグを使うと、ページ全体が再レンダリングされる
- `Link`コンポーネントは、Client側のナビゲーションを担当
- `Link`コンポーネントは、変更部分のみレンダリング(layout.tsxなどは無駄にレンダリングされない)
- Next.jsはルートセグメントによってアプリケーションを自動的にコード分割している(ブラウザが最初のロード時にすべてのアプリケーションコードをロードする従来のSPAとの違い)
- ルートセグメントによってコードが分割 = ページが分離されており、特定のページがエラーをスローしてもアプリケーションの残りの部分は動作する
- 本番環境では、`<Link>`コンポーネントがブラウザのビューポートに表示されるたびに、Next.jsはバックグラウンドでリンクされたルートのコードを自動的にプリフェッチする
- ユーザーがリンクをクリックするころには、リンク先ページのコードはすでにバックグラウンドで読み込まれており、ページ遷移が早くなる

## データの取得
- Next.jsでデータをfetchする方法は主に以下
  - API層
    - **API を提供するサードパーティサービスを使用している場合**(SupabaseやFirebaseなど)
    - クライアントからデータを取得する場合は、データベースの秘密がクライアントに公開されるのを避けるために、サーバー上で実行される API層が必要
    - Next.jsでは[Router Hadlers](https://nextjs.org/docs/app/building-your-application/routing/route-handlers)を使用して、APIエンドポイントを作成できる
  - データベースクエリ
    - **フルスタックアプリケーションを作成する場合**
    - その中でも、以下の2種類がある
      - PrismaなどのORMを使ってAPIエンドポイントからDBと対話する
      - React Server Components(RSC) を使用する(API層を介さずにセキュアにDBに直接クエリを実行できる)
- デフォルトではNext.jsはReact Server Componentsを使用している
  - ※ 必要に応じてクライアントコンポーネントをオプトインできる
- RSCのメリット
  - サーバー上で実行されるため、高価なデータ取得やロジックをサーバー上に保持し、結果のみをクライアントに送信することができる
  - RSCはpromiseをサポートしており、データ取得のような非同期タスクのためのシンプルなソリューションを提供。useEffectやuseStateなどのデータ取得ライブラリを使わずに、async/await構文を使用できる
  - サーバー上で実行されるため、APIレイヤーを追加することなく、データベースに直接問い合わせることができます。
- Next.jsではデフォルトで`request waterfall`を作成する
  - `request waterfall` は、他のリクエストが完了するまで待機して順次実行していくリクエストの仕方
  - ex: リクエストAが完了するまでリクエストBは実行されない
  - 並列でデータをfetchすることで対策できる
    - JavascriptのPromise.allを使って、並列でデータをfetchすることができる
